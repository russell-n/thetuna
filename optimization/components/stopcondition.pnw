The Stop Conditions
===================
<<name='imports'>>=
# python standard library
import time
@

The Stop Conditions are callable objects used by the optimizers to decide when to stop.

Contents:

   * :ref:`The Stop Condition <optimization-components-stopcondition>`
   * :ref:`The Stop Condition with Ideal Value <optimization-components-stopcondition-ideal>`

.. _optimization-components-stopcondition:
   
The Stop Condition
------------------

.. uml::

   StopCondition : end_time
   StopCondition : time_limit
   StopCondition : __call__(solution)

.. currentmodule:: optimization.components.stopcondition
.. autosummary::
   :toctree: api

   StopCondition

<<name='StopCondition', echo=False>>=
class StopCondition(object):
    """
    A halting-condition for the optimizers
    """
    def __init__(self, time_limit, end_time=None):
        """
        StopCondition constructor

        :param:

         - `end_time`: (ctime) time-out
         - `time_limit`: max seconds from first call before stop
        """
        self._end_time = end_time
        self.time_limit = time_limit
        return

    @property
    def end_time(self):
        """
        C-time to stop
        """
        if self._end_time is None:
            self._end_time = self.time_limit + time.time()
        return self._end_time

    def __call__(self, solution=None):
        """
        Returns False until it's time to stop

        :param:

         - `solution`: Candidate solution, not used here
        """
        return time.time() >= self.end_time
# end StopCondition    
@

.. _optimization-components-stopcondition-ideal:

Stop Condition with Ideal-Value Check
-------------------------------------

The algorithms given in [EOM]_ use two conditions for stopping -- either reaching the ideal optimization point or running out of time. I'm assuming that in most cases running out of time is the actual limit that will be used, but for the cases where a threshold is known, the StopConditionIdeal will check both the values and the time.

.. '

.. uml::

   StopCondition <|-- StopConditionIdeal

.. autosummary::
   :toctree: api

   StopConditionIdeal
   StopConditionIdeal.__call__

<<name='StopConditionIdeal', echo=False>>=
class StopConditionIdeal(StopCondition):
    """
    Stop condition for the optimizers with known ideal values
    """
    def __init__(self, ideal_value, delta=0.001, *args, **kwargs):
        """
        StopConditionIdeal constructor

        :param:

         - `end_time`: ctime to quit
         - `time_limit`: maximum second to allow
         - `ideal_value`: value if reached will stop the optimizers
         - `deltay`: difference from the ideal_value to accept
        """
        super(StopConditionIdeal, self).__init__(*args, **kwargs)
        self.ideal_value = ideal_value
        self.delta = delta
        
        return

    def __call__(self, solution=None):
        """
        Returns False until it's time to stop

        :param:

         - `solution`: Candidate solution to test against ideal
        """
        return (abs(solution.output - self.ideal_value) <= self.delta or
                time.time() >= self.end_time)
# end StopConditionIdeal
@

.. note:: the call method for the StopConditionIdeal compares the candididate solution to the ideal value using a '>=' inequality, so if solutions are objects instead of numbers they have to be able to have the inequality operations defined (e.g. ``__eq__``, ``__gte__``, etc.).
