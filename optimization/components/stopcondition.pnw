The Stop Conditions
===================
<<name='imports'>>=
# python standard library
import time
import random
@

The Stop Conditions are callable objects used by the optimizers to decide when to stop.

Contents:

   * :ref:`The Stop Condition <optimization-components-stopcondition>`
   * :ref:`The Stop Condition with Ideal Value <optimization-components-stopcondition-ideal>`
   * :ref:`The Stop Condition Generator <optimization-components-stopcondition-generator>`

.. _optimization-components-stopcondition:
   
The Stop Condition
------------------

.. uml::

   StopCondition : end_time
   StopCondition : time_limit
   StopCondition : __call__(solution)

.. currentmodule:: optimization.components.stopcondition
.. autosummary::
   :toctree: api

   StopCondition
   StopCondition.time_limit
   StopCondition.end_time
   StopCondition.__call__
   StopCondition.reset

<<name='StopCondition', echo=False>>=
class StopCondition(object):
    """
    A halting-condition for the optimizers
    """
    def __init__(self, time_limit, end_time=None):
        """
        StopCondition constructor

        :param:

         - `end_time`: (ctime) time-out
         - `time_limit`: max seconds from first call before stop
        """
        self._end_time = end_time
        self._time_limit = time_limit
        return

    @property
    def time_limit(self):
        """
        The max seconds to allow
        """
        return self._time_limit

    @time_limit.setter
    def time_limit(self, new_limit):
        """
        Sets the time-limit and resets the end-time

        :param:

         - `new_limit`: max seconds to allow

        :postcondition: self._end_time is None
        """
        self._time_limit = new_limit
        self._end_time = None

    @property
    def end_time(self):
        """
        C-time to stop
        """
        if self._end_time is None:
            self._end_time = self.time_limit + time.time()
        return self._end_time

    @end_time.setter
    def end_time(self, new_time):
        """
        sets the time to stop

        :param:

         - `new_time`: c-time to stop
        """
        self._end_time = new_time
        return

    def __call__(self, solution=None):
        """
        Returns False until it's time to stop

        :param:

         - `solution`: Candidate solution, not used here
        """
        return time.time() >= self.end_time

    def reset(self):
        """
        Resets the end_time to None
        """
        self._end_time = None
        return
# end StopCondition    
@

.. _optimization-components-stopcondition-ideal:

Stop Condition with Ideal-Value Check
-------------------------------------

The algorithms given in [EOM]_ use two conditions for stopping -- either reaching the ideal optimization point or running out of time. I'm assuming that in most cases running out of time is the actual limit that will be used, but for the cases where a threshold is known, the StopConditionIdeal will check both the values and the time.

.. '

.. uml::

   StopCondition <|-- StopConditionIdeal

.. autosummary::
   :toctree: api

   StopConditionIdeal
   StopConditionIdeal.__call__

<<name='StopConditionIdeal', echo=False>>=
class StopConditionIdeal(StopCondition):
    """
    Stop condition for the optimizers with known ideal values
    """
    def __init__(self, ideal_value, delta=0.001, *args, **kwargs):
        """
        StopConditionIdeal constructor

        :param:

         - `end_time`: ctime to quit
         - `time_limit`: maximum second to allow
         - `ideal_value`: value if reached will stop the optimizers
         - `deltay`: difference from the ideal_value to accept
        """
        super(StopConditionIdeal, self).__init__(*args, **kwargs)
        self.ideal_value = ideal_value
        self.delta = delta        
        return

    def __call__(self, solution=None):
        """
        Returns False until it's time to stop

        :param:

         - `solution`: Candidate solution to test against ideal
        """
        return (abs(solution.output - self.ideal_value) <= self.delta or
                time.time() >= self.end_time)
# end StopConditionIdeal
@

.. note:: the call method for the StopConditionIdeal compares the candididate solution to the ideal value using a '>=' inequality, so if solutions are objects instead of numbers they have to be able to have the inequality operations defined (e.g. ``__eq__``, ``__gte__``, etc.).

.. _optimization-components-stopcondition-generator:

The Stop Condition Generator
----------------------------

The StopConditionGenerator creates StopConditions (Ideal) with random end-times.

.. autosummary::
   :toctree: api

   StopConditionGenerator
   StopConditionGenerator.random_function
   StopConditionGenerator.end_time
   StopConditionGenerator.stop_condition
   StopConditionGenerator.global_stop_condition
   StopConditionGenerator.__iter__

<<name='StopConditionGenerator'>>=
class StopConditionGenerator(object):
    """
    A creator of randomized stop conditions
    """
    def __init__(self, time_limit, maximum_time, minimum_time=1, 
                 end_time=None, ideal=None, delta=0, use_singleton=True, random_function=random.uniform):
        """
        StopConditionGenerator

        :param:

         - `time_limit`: number of seconds to generate stop-conditions
         - `maximum_time`: upper-bound on the number of seconds
         - `minimum_time`: lower-bound on the number of seconds
         - `end_time`: ctime to end
         - `ideal`: value to compare test-cases to for stop-condition
         - `delta`: amount test-case can differ from ideal
         - `use_singleton`: Generate same StopCondition object
         - `random_function`: Function to get time-out values (default is random.uniform)
        """
        self.time_limit = time_limit
        self.maximum_time = maximum_time
        self.minimum_time = minimum_time
        self._end_time = end_time
        self.ideal = ideal
        self.delta = delta
        self.use_singleton = use_singleton
        self.random_function = random_function
        self._stop_condition = None
        self._global_stop_condition = None
        self.abort = False
        return

    @property
    def end_time(self):
        """
        The ctime to stop all stop-conditions (time-limit + now)
        """
        if self._end_time is None:
            self._end_time = time.time() + self.time_limit
        return self._end_time

    @property
    def global_stop_condition(self):
        """
        A stop condition using the total time instead of the random-times
        """
        if self._global_stop_condition is None:
            if self.ideal is None:
                self._global_stop_condition = StopCondition(time_limit=self.time_limit,
                                                            end_time=self.end_time)
            else:
                self._global_stop_condition = StopConditionIdeal(time_limit=self.time_limit,
                                                                 end_time=self.end_time,
                                                                 ideal_value=self.ideal,
                                                                 delta=self.delta)
        return self._global_stop_condition
    
    @property
    def stop_condition(self):
        """
        A Stop-Condition object with new end-time set every time it's retrieved
        Or a new StopCondition object every-time it's retrieved if not use_singleton
        """
        time_limit = self.random_function(self.minimum_time,
                                          self.maximum_time)
        # set an upper-bound on times
        end_time = min(time_limit + time.time(), self.end_time)

        # this probably isn't necessary, but for checks there should be
        # some consistency, I think
        if end_time == self.end_time:
            time_limit = self.time_limit

        if self._stop_condition is None or not self.use_singleton:                
            if self.ideal is None:                
                self._stop_condition = StopCondition(time_limit=time_limit,
                                                     end_time=end_time)
            else:
                self._stop_condition = StopConditionIdeal(time_limit=time_limit,
                                                          end_time=end_time,
                                                          ideal_value=self.ideal,
                                                          delta=self.delta)
        elif self.use_singleton:
            # the object existed, we need to give it new times
            self._stop_condition.time_limit = time_limit
            self._stop_condition.end_time = end_time
        return self._stop_condition

    def __iter__(self):
        """
        generates stop-conditions
        """
        while time.time() < self.end_time:
            yield self.stop_condition
            if self.abort:
                break
        return

    def reset(self):
        """
        Resets some values (assumes iter already done)
        """
        self.abort = False
        self._end_time = None
        self._global_stop_condition = None
        if self.use_singleton:
            self._stop_condition.time_limit = time_limit
            self._stop_condition.end_time = end_time
        return
@

The StopConditionGenerator generates StopConditions. The first time it generates one it will set the end_time based on the `time_limit` unless it was already set. This way it won't exceed the maximum time. Each StopCondition will get a different time-out that's randomly generated based on the ``time_limit`` and ``minimum_time``.

.. csv-table:: StopConditionGenerator Parameters
   :header: Name, Description

   ``time_limit``, Seconds to generate stop-conditions
   ``maximum_time``,Upper-bound for the amount of time each StopCondition will run
   ``minimum_time``, Lower-bound for the amount of time each StopCondition will run
   ``end_time``, c-time to stop generation
   ``ideal``, If set the conditions will stop when the test value is close enough to it
   ``delta``, Difference from ideal for stop-condition
   ``use_singleton``, If True use same stop-condition object (but change the time-outs)
   ``random_function``, Function to use instead of random.uniform to get time-outs

Right now the times are generated uniformly, so the expected call will be ``random.uniform(minimum_time, time_limit)``. If you want to use a different function you can pass it into the constructor, so long as it can be called with the same values.

The ``use_singleton`` is a little misleading -- the ``StopConditionGenerator`` stores the object but creating a new ``StopConditionGenerator`` will create a new StopCondition so it's not a True singleton.

.. '

Although you could pull the `stop_condition` property to get new stop-conditions, the intention is to use it as and iterator. Let's assume you have a StopConditionGenerator object named `stop_generator`, then the way to used it might be something like::

    for stop_condition in stop_generator:
        while not stop_condition(candidate):
            new_candidate = Tweak(candidate)
            if Quality(new_candidate) > Quality(candidate):
                candidate = new_candidate
    return candidate
