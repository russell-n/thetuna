The Iperf Metric
================

<<name='imports', echo=False>>=
# python standard library
from collections import OrderedDict

# tuna
from component import BaseComponent
from tuna import ConfigurationError
from tuna.plugins.base_plugin import BasePlugin
@

These are classes meant to be dropped into place where `Quality` classes are called. They take csv-files, convert them to arrays and return matching output values based on indices of the arrays.

<<name='IperfDataConstants'>>=
class IperfDataConstants(object):
    """
    Constants for builders of the XYData class
    """
    __slots__ = ()
    filename_option = 'filename'
    delimiter_option = 'delimiter'
    skiprows_option = 'skiprows'
    usecols_option = 'usecols'
@

The IperfData Quality
---------------------

This `quality` metric runs iperf on two `hosts` and takes returns the median bandwidth as the `quality` of their end-to-end connection. The language used can be sort of confusing, but here one of the hosts is called a `client` and the other a `server`, even though they can assume either role when running iperf. The assumption is that the `client` is the device that is being tested while the `server` is a well-provisioned server that facilitates the testing.

.. uml::

   BaseComponent <|-- IperfDataQuality

.. currentmodule:: tuna.components.iperfmetric
.. autosummary::
   :toctree: api

   IperfDataQuality
   IperfDataQuality.client
   IperfDataQuality.server
   IperfDataQuality.IperfClientSettings
   IperfDataQuality.IperfServerSettings
   IperfDataQuality.product
   XYDataQuality.__call__
   XYDataQuality.check_rep
   XYDataQuality.close

<<name='constants'>>=
CONFIGURATION = """
[IperfData]
# this follows the pattern for plugins --
# the header has to match what's in the Optimizers `components` list
# the component option has to be XYData
component = Iperf

# to shorten this section the configuration
# for the client (DUT) and server (Traffic PC)
# are broken out so you have to indicate their
# section names here (this is case-sensitive)
client_section = DUT
server_section = TPC

# direction can be anything that starts with 'u' (for upstream only)
# 'd' (downstream only), or 'b' (both)
# where upstream means DUT -> Server
# and downstream means SERVER -> DUT
direction = both

# iperf settings
# these can be any long-form iperf options (without the dashes)
# so looking at the iperf man page (or `iperf -h`) will give you the valid options
# note that in some cases iperf uses shortenings (e.g. `len` vs `length`)
# Any option not given will use the iperf defaults
parallel = 4

[DUT]
# this is an example for the connection to the dut
# the section header has to match what's declared in the
# iperf section

# the connection can be ssh or telnet
connection_type = ssh
control_ip = 192.168.10.50
test_ip = 192.168.20.50
username = tester
# password is optional if host-keys are set up
# and you are using ssh
# password = testlabs
# the prefix will be appended to all commands sent to the device
# the main uses are adding 'adb shell' or path-directories
# because these two cases are different (`adb shell` is space separated from commands
# while setting a PATH has to be semi-colon separated) the prefix is added as-is
# it's up to the user to create a sensible one
# prefix = PATH=/opt/wifi:$PATH; adb shell

# timeout is amount of time to allow a command to run before giving up
# because timeouts cause an error, this should only be used for problematic
# devices
# timeout = 1 minute 30 seconds

# operating-system is just an identifier currently
# operating_system = linux

[TPC]
# this is basically configured the same way as the client-section
connection_type = ssh
control_ip = 192.168.10.50
test_ip = 192.168.20.50
username = tester
"""

DESCRIPTION = """
The Iperf quality metric
"""
@

<<name='XYDataQuality', echo=False>>=
class XYDataQuality(BaseComponent):
    """
    A csv-file to quality-value translator
    """
    def __init__(self, filename, delimiter=',', skiprows=0,
                 usecols=None):
        """
        XYData Constructor

        :param:

         - `filename`: name of csv-file
         - `delimiter`: column separator
         - `skiprows`: number of rows in file to skip
         - `usecols`: specific columns to use         
        """
        super(XYDataQuality, self).__init__()
        self.filename = filename
        self.delimiter = delimiter
        self.skiprows = skiprows
        self.usecols = usecols
        self.quality_checks = 0
        self.configuration = CONFIGURATION
        self._data = None
        return


    @property
    def data(self):
        """
        numpy array built from the csv-file
        """
        if self._data is None:
            self._data = numpy.loadtxt(self.filename,
                                       delimiter=self.delimiter,
                                       skiprows=self.skiprows,
                                       usecols=self.usecols)
        return self._data

    def __call__(self, target):
        """
        Main interface, sets the target.output value, increments self.quality_checks

        :param:

         - `target`: object with  with <x-index, y-index> for `input` attribute`

        :return: value from data at coordinates
        """
        self.quality_checks += 1
        if target.output is None:
            target.output = self.data[target.inputs[0], target.inputs[1]]
        return target.output

    def check_rep(self):
        """
        Checks the flie parameters
        """
        if not os.path.isfile(self.filename):
            raise ConfigurationError("'{0}' is not a valid filename".format(self.filename))
        if not type(self.delimiter) is StringType:
            raise ConfigurationError("'{0}' is not a valid delimiter".format(self.delimiter))
        if not type(self.skiprows) is IntType:
            raise ConfigurationError("'{0}' is not a valid skiprows value".format(self.skiprows))
        return

    def close(self):
        """
        logs the number of quality-check- made and calls reset()
        """
        self.logger.info("Quality Checks: {0}".format(self.quality_checks))
        self.reset()
        return

    def reset(self):
        """
        Resets the quality_checks to 0
        """
        #self.logger.debug("Quality Checks: {0}".format(self.quality_checks))
        self.quality_checks = 0
        return
# end XYData    
@

To match the older-code the call has to expect an object of the form:

.. uml::

   Data : inputs
   Data : output

If the output is not set it sets it using the inputs and returns the output. It also maintains a count of all the calls made (`self.quality_checks`) so that the efficiency can be double-checked.

The XYData Builder
------------------

A convenience class for building `XYData` objects. It implements the plugin interface so the help and list sub-commands can use it.

.. uml::

   BasePlugin <|-- XYDataBuilder

.. currentmodule:: tuna.components.dataquality
.. autosummary::
   :toctree: api

   XYData
   XYData.product
    
<<name="XYData", echo=False>>=
class XYData(BasePlugin):
    """
    Builds XYData objects from configuration-maps
    """
    def __init__(self, *args, **kwargs):
        """
        XYDataBuilder constructor

        :param:

         - `configuration`: configuration map
         - `section`: name of section with needed options
        """
        super(XYData, self).__init__(*args, **kwargs)
        return

    @property
    def product(self):
        """
        A built XYData object
        """
        if self._product is None:
            filename = self.configuration.get(section=self.section_header,
                                              option=XYDataConstants.filename_option,
                                              optional=False)
            delimiter = self.configuration.get(section=self.section_header,
                                               option=XYDataConstants.delimiter_option,
                                               optional=True,
                                               default=',')
            skiprows = self.configuration.get_int(section=self.section_header,
                                                  option=XYDataConstants.skiprows_option,
                                                  optional=True,
                                                  default=0)
            usecols = self.configuration.get_list(section=self.section_header,
                                                  option=XYDataConstants.usecols_option,
                                                  optional=True)
            if usecols is not None:
                usecols = [int(item) for item in usecols]
            self._product = XYDataQuality(filename=filename,
                                   delimiter=delimiter,
                                   skiprows=skiprows,
                                   usecols=usecols)
        return self._product

    @property
    def sections(self):
        """
        An ordered dictionary for the HelpPage
        """
        if self._sections is None:
            bold = '{bold}'
            reset = '{reset}'
            name = 'XYData'
            bold_name = bold + name + reset

            self._sections = OrderedDict()
            self._sections['Name'] = '{blue}' + name + reset + ' -- A component for optimizer plugins'
            self._sections['Description'] = bold_name + DESCRIPTION
            self._sections["Configuration"] = CONFIGURATION
            self._sections['Files'] = __file__
        return self._sections

    def fetch_config(self):
        """
        prints sample configuration to the scree
        """
        print CONFIGURATION
        return

@
