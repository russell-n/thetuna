Simulated Annealing With Simulated Table Data
=============================================

Problem
-------

*How can we understand how the `Simulated Annealing` parameters should be set while trying to optimize device placement on a table?*

In order to make the optimization work we need to know how to set the parameters that affect whether the optimizer will emphasize *exploration* or *exploitation* (will it jump around a lot or will it stick to looking around where it is?). We also need to know a reasonable stopping condition -- setting an ideal value would allow a short-circuit to end the optimization but runs the risk that we've chosen an incorrect ideal value, while setting a time-out runs the risk of either being too short and missing the optimal value or being too long and searching needlessly while delaying moving on to the next phase of the experiment.

.. '

What we'll do here is use data collected by exhaustively sweeping a table and passing it to the optimizer to see how it performs. Since we did an exhaustive sweep we know what the best and worst cases are so we can see how many times the optimizer has to lookup a value to see how good a candidate is. The count of lookups can then be compared with a `real` iperf session or by estimating the number of seconds each lookup would take. The second option isn't as straight-forward as it may seem because the candidates store their solutions once they are given so a candidate may be asked for its solution multiple times but there would only be one real check (meaning one iperf session run) and the remainder of the times the solution would be retrieved from memory.

The Simulation Data
-------------------

Alex created the data-set (:download:`download <data/data_step50.csv>`) by stepping through the table coordinates (with a step-size of 50) while the table was inside one a Faraday cage and measuring throughput using iperf. I don't know what the scale is in human terms but the annealer doesn't need to know. The file is a csv with the row-indices assumed to be the y-values and the column-indices assumed to the be the x-values (both scaled by the step-size of 50). The values are the iperf bandwidth measurements for the location on the table (the traffic was run downstream for 5 seconds with the TCP window set to 256 K).

I'll examine the data so we can see what the Simulated Annealer is working with.

.. '

Data Plots
~~~~~~~~~~

<<name='imports', echo=False>>=
# python standard library
from itertools import izip

# third party
import numpy
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm
import matplotlib.pyplot as plt
from scipy.stats import gaussian_kde
import pandas
@

<<name='load_data', echo=False>>=
data_path = 'data/data_step50.csv'
z_data = numpy.loadtxt(data_path, delimiter=',')
flat_data = numpy.reshape(z_data, -1)
width, height = z_data.shape
x_data = numpy.linspace(start=0, stop=3000, num=width)
y_data = numpy.linspace(start=0, stop=3000, num=height)
x_data, y_data = numpy.meshgrid(x_data, y_data)
@

<<name='plot_profile', echo=False, results='sphinx'>>=
output = 'figures/data_profile.png'
figure = plt.figure()
axe = figure.add_subplot(111, projection='3d')
axe.plot_surface(x_data, y_data, z_data, cmap=cm.winter)
axe.elev -= 30
axe.azim += 60
figure.savefig(output)
print '.. figure:: ' + output
print "   :scale: 75%"
@
   *Side View* (0,0) is at rear-left, (3000,3000) at front right, z-axis is Mbits/second.

I don't know how the grid corresponds to actual locations of things so I'm assuming that the origin marks the front-left of the table (whatever 'front' means). It looks like the front of the table gets better throughput than the back.

<<name='plot_angled', echo=False, results='sphinx'>>=
output = 'figures/data_angled.png'
figure = plt.figure()
axe = figure.add_subplot(111, projection='3d')
axe.plot_surface(x_data, y_data, z_data, cmap=cm.winter)
figure.savefig(output)
print '.. figure:: ' + output
print "   :scale: 75%"
@

<<name='binning_data', echo=False>>=
noughts = flat_data[flat_data < 10]
tens = flat_data[flat_data < 20]
tens = tens[tens >= 10]
twenties = flat_data[flat_data < 30]
twenties = twenties[twenties >= 20]
thirties = flat_data[flat_data < 40]
thirties = thirties[thirties >= 30]
forties = flat_data[flat_data < 50]
forties = forties[forties >= 40]
fifties = flat_data[flat_data >= 50]
fifties = fifties[fifties < 60]
sixties = flat_data[flat_data >=60]
sixties = flat_data[sixties < 70]
seventies = flat_data[flat_data >= 70]
@
   
<<name='contour_data', echo=False, results='sphinx', wrap=False>>=
max_value = z_data.max()
min_value = z_data.min()

max_index = numpy.where(z_data == max_value) 
min_index = numpy.where(z_data == min_value)

max_index_x = max_index[0][0] * 50
max_index_y = max_index[1][0] * 50

min_index_x = min_index[0][0] * 50
min_index_y = min_index[1][0] * 50


output = 'figures/contoured.png'
figure=plt.figure()
axe = figure.gca()
c_data = axe.contour(y_data, x_data, z_data)
axe.clabel(c_data)
axe.axvline(max_index_x, color='r')
axe.axhline(max_index_y, color='r')

axe.axvline(min_index_x, color='b')
axe.axhline(min_index_y, color='b')
axe.set_title("Contour Map")
figure.savefig(output)
print ".. figure:: " + output
print "   :scale: 75%"
print
print "   Max-throughput ({0} Mb/s) at ({1}, {2}) indicated by intersection of red lines. Min-throughput ({3} Mb/s) at ({4}, {5}) indicated by intersection of blue lines.\n".format(max_value,
                                                                                     max_index_x,
                                                                                     max_index_y,
                                                                                     min_value,
                                                                                     min_index_x,
                                                                                     min_index_y)

@


The contour map gives a somewhat more informative view. You can see that one side of the table tends to get more of the good throughput (which I think Bryce and Brent indicated).
 
<<name='scatter_data', echo=False, results='sphinx', wrap=False>>=
output = 'figures/best_worst_scatter.png'
figure=plt.figure()
axe = figure.gca()

data_10 = numpy.where(z_data < 10)
data_70 = numpy.where(z_data >= 70)
colors = 'black red'.split()
data = (data_10, data_70)

axe.scatter(data_10[0] * 50, data_10[1] * 50,
                edgecolors='black',
                facecolors='none')
axe.scatter(data_70[0] * 50, data_70[1] * 50,
                edgecolors='red',
                facecolors='none')

axe.axvline(max_index_x, color='r')
axe.axhline(max_index_y, color='r')

axe.axvline(min_index_x, color='b')
axe.axhline(min_index_y, color='b')
axe.set_xlim((0, 3000))
axe.set_ylim((0, 3000))
axe.set_title("Best and Worst")
figure.savefig(output)
print ".. figure:: " + output
print "   :scale: 75%"
print
print "   Best and worst throughput locations. Black indicates < 10 Mbits/second. Red indicates > 70 Mbits/second."
print "   Intersection of red lines indicate best overall location. Intersection of blue lines indicate worst location."
@

The best points appear to have a clear bias toward the left side, and the worst points do appear to be a little denser to the right, but for the most part the worst points appear to be nearly randomly scattered around the table.

Summary Statistics
~~~~~~~~~~~~~~~~~~

.. csv-table:: Summary Table
   :header: Statistic, Value

<<name='summary', echo=False, results='sphinx'>>=
z_series = pandas.Series(flat_data)
description = z_series.describe()

for stat in description.index:
    print "   {0},{1:g}".format(stat, description.ix[stat])
@

<<name='box_plot', echo=False, results='sphinx'>>=
output = 'figures/box_plot.png'
figure = plt.figure()
axe = figure.gca()
axe.set_title("Throughput")
axe.boxplot(flat_data)
axe.set_ylabel("Mbits/sec")
figure.savefig(output)
print ".. figure:: " + output
print "     :scale: 75%"
@

We can see from the box-plot that the data is fairly spread out and left-skewed.

<<name='plot_kde', echo=False, results='sphinx'>>=
frame = pandas.DataFrame(z_data)
output = 'figures/data_kde.png'
figure = plt.figure()
axe = figure.gca()

stacked = frame.stack()
stacked.hist(ax=axe, alpha=0.25, color='k', normed=1)
stacked.plot(kind='kde', ax=axe, alpha=0.5, color='b')

axe.axvline(numpy.median(flat_data), color='r', alpha=0.5)
axe.set_xlabel("Throughput (Mb/s)")

figure.savefig(output)
print '.. figure:: ' + output
print "   :scale: 75%"
@

Looking at the distribution we can see there are two (possibly 3) sub-distributions with a significant amount of data under 10 Mbits/second.

<<name='plot_cdf', echo=False, results='sphinx'>>=
output = 'figures/data_cdf.png'
figure = plt.figure()
axe = figure.gca()
normed = flat_data/flat_data.sum()
cumulative_data = numpy.cumsum(normed)
#axe.plot(cumulative_data)
out = axe.hist(flat_data, normed=True, cumulative=True, bins=500, histtype='step')
out = axe.set_xlim((0, flat_data.max()))
out = axe.set_ylim((0, 1))
out = axe.set_title("Cumulative Distribution")
out = plt.axvline(numpy.median(flat_data), color='r')
figure.savefig(output)
print '.. figure:: ' + output
print "  :scale: 75%"
@

Looking at the left-hand side of the CDF we can see that there's a jump of about 5% very near 0 Mbits/Second so that initial bump in the KDE/Histogram is for data points that are very near 0. We can check the proportion of points that are less than 1 Mbits/second to see.

.. '

<<name='less_than_one'>>=
total = float(len(flat_data))
less_than_one = flat_data[flat_data < 1]
@
<<name='print_less_than_one', echo=False, results='sphinx'>>=
print "**Less than 1 Mbits/Second:** {0:.3g}".format(len(less_than_one)/total)
@

So about 5% of the data is less than 1 Mbits/second.

.. csv-table:: Binned Fractions
   :header: Values, Count, Fraction of Total

<<name='bins', echo=False, results='sphinx'>>=
print "   0-9,{0},{1:.3f}".format(len(noughts), len(noughts)/total)
print "   10-19,{0},{1:.3f}".format(len(tens), len(tens)/total)
print "   20-29,{0},{1:.3f}".format(len(twenties), len(twenties)/total)
print "   30-39,{0},{1:.3f}".format(len(thirties), len(thirties)/total)
print "   40-49,{0},{1:.3f}".format(len(forties), len(forties)/total)
print "   50-59,{0},{1:.3f}".format(len(fifties), len(fifties)/total)
print "   60-69,{0},{1:.3f}".format(len(sixties), len(sixties)/total)
print "   >= 70,{0},{1:.3f}".format(len(seventies), len(seventies)/total)
@

If the whole table is searched you would have about a 50-50 chance of getting a value greater than 50 Mbits/second just by randomly picking a location, but less than 1% chance of getting throughput greater than 70 Mbits/Second and a 5% chance of getting less than 1 Mbits/second. Looking at the plot of just the best and worst points above you can see that the best points disappear just before the half way point (from left to right). If we somehow knew in advance that this was always true, we could limit the search to just the left half of the table and improve the chances of finding a location with better values.


The Neighborhood
~~~~~~~~~~~~~~~~

These are the points surrounding the minimum and maximum values for the entire data set. First the neighborhood around the maximum value.

.. figure:: figures/bad_neighborhood.svg

.. <<name='maximum_neighborhood', echo=False>>=
.. print z_data[5:10, 49:54]
.. @

I'm using index slicing so the arrays are arranged backwards and upside down -- the values in the fifties are to the right of the center when looking at the plots but listed to the left of center in the arrays. 

The arrows represent a path that a hill climber using a local search might take. The three blue circles are local optima that prevent their neighbors from reaching the global optima (the blue rectangle). Of the sixteen nodes making up the outer ring, eleven fail to reach the global optima and 5 are able to find it. All five approach the global optima from the top right. I'm assuming that the nodes in the outer ring are themselves all reachable but that might not be the case if the entire grid was used.

.. <<name='minimum_neighborhood', echo=False>>=
.. print z_data[22:28, 57:64]
.. @

.. figure:: figures/worst_neighborhood.svg

In the case of the worst data point (in the blue rectangle), it occurred near the edge of the table so I left the right most column empty. Just below the lowest point is another local optima which would trap a hill-climber. The minimum doesn't appear to have any real relationship to the data-points around them. It would be interesting to find out why the dead-spots occur.

While working on the diagram it occurred to me that if a hill-climber only looks at its nearest neighbors (one cell away) then the dead-spots would generally not be picked as a next step, since they don't appear to be clustered and the climber would always pick the adjacent neighbor with the higher value. This means that there would be cells on the table that the climber might never see if they happened to be surrounded by a buffer of lower-valued cells. This wouldn't be the case for Simulated Annealing, which occasionally picks the solution that is worse than the current solution (and doesn't do a local search anyway).

Partitioning the Data
~~~~~~~~~~~~~~~~~~~~~

If we know that the data will always look like the set we have, we can reduce our search space to just the left half of the table. Here I'll see how that affects the probability of finding the best value.

<<name='partition', echo=False>>=
partition = int(width/2.)
z_sub = z_data[:partition,:]
width, height = z_sub.shape
x_data = numpy.linspace(0, 1500, num=width)
y_data = numpy.linspace(start=0, stop=3000, num=height)
x_data, y_data = numpy.meshgrid(y_data, x_data)
@

<<name='plot_partition', echo=False, results='sphinx'>>=
output = 'figures/sub_set.png'
figure=plt.figure()
axe = figure.gca()
c_data = axe.contour(y_data, x_data, z_sub)
axe.clabel(c_data)
axe.set_title("Contour Map (Left Half)")
figure.savefig(output)
print ".. figure:: " + output
print "   :scale: 75%"
@

<<name='sub_scatter_data', echo=False, results='sphinx', wrap=False>>=
output = 'figures/sub_scatter.png'
figure=plt.figure()
axe = figure.gca()

data_10 = numpy.where(z_sub < 10)
data_70 = numpy.where(z_sub >= 70)
colors = 'black red'.split()
data = (data_10, data_70)

axe.scatter(data_10[0] * 50, data_10[1] * 50,
                edgecolors='black',
                facecolors='none')
axe.scatter(data_70[0] * 50, data_70[1] * 50,
                edgecolors='red',
                facecolors='none')

axe.axvline(max_index_x, color='r')
axe.axhline(max_index_y, color='r')

axe.axvline(min_index_x, color='b')
axe.axhline(min_index_y, color='b')
axe.set_xlim((0, 1500))
axe.set_ylim((0, 3000))
axe.set_title("Best and Worst (Left Side)")
figure.savefig(output)
print ".. figure:: " + output
print "   :scale: 75%"
print
print "   Best and worst throughput locations. Red indicates < 10 Mbits/second. Black indicates > 70 Mbits/second."
@

.. csv-table:: Binned Fractions (Left Half)
   :header: Values, Count, Fraction of Total

<<name='sub_bins', echo=False, results='sphinx'>>=
flat_data = numpy.reshape(z_sub, -1)
noughts = flat_data[flat_data < 10]
tens = flat_data[flat_data < 20]
tens = tens[tens >= 10]
twenties = flat_data[flat_data < 30]
twenties = twenties[twenties >= 20]
thirties = flat_data[flat_data < 40]
thirties = thirties[thirties >= 30]
forties = flat_data[flat_data < 50]
forties = forties[forties >= 40]
fifties = flat_data[flat_data >= 50]
fifties = fifties[fifties < 60]
sixties = flat_data[flat_data >=60]
sixties = flat_data[sixties < 70]
seventies = flat_data[flat_data >= 70]

total = float(len(flat_data))
print "   0-9,{0},{1:.3f}".format(len(noughts), len(noughts)/total)
print "   10-19,{0},{1:.3f}".format(len(tens), len(tens)/total)
print "   20-29,{0},{1:.3f}".format(len(twenties), len(twenties)/total)
print "   30-39,{0},{1:.3f}".format(len(thirties), len(thirties)/total)
print "   40-49,{0},{1:.3f}".format(len(forties), len(forties)/total)
print "   50-59,{0},{1:.3f}".format(len(fifties), len(fifties)/total)
print "   60-69,{0},{1:.3f}".format(len(sixties), len(sixties)/total)
print "   >= 70,{0},{1:.3f}".format(len(seventies), len(seventies)/total)
@

If only the left-half of the table were searched then you would have about a 77% chance of getting 50 Mbits/second or higher, but the chance of getting greater than 70 Mbits/second remains low at around 2%. The fraction of data points less than 10 Mbits/second goes down only 1% (from 0.059 to 0.049).


Pseudocode for Simulated Annealing
----------------------------------

To get an idea of the parameters that need to be adjusted it might be helpful to understand the basic simulated annealing operation.

   1. Get a candidate solution
   2. Make the current solution and the best solution the candidate solution
   3. While time remains and the best solution is not the ideal solution repeat:

      3.1. Get a new candidate by tweaking the current solution

      3.2. If new candidate is better than current solution or a random number is less than the annealing value, make the current solution the new candidate

      3.3. If the current solution is better than the best solution, make the current solution the best solution

   4. Return the best solution

The two points that we need to look at are 3.1. (get a new candidate by tweaking the current solution) and 3.2. (... a random number is less than the annealing value).

Simulated Annealing
-------------------

First let's look at `3.2. (a random number is less than the annealing value)`.

The :ref:`SimulatedAnnealing <optimization-optimizers-simulatedannealing-background>` documentation has more detail of how it works but the main thing to note here is that we determine how it behaves by setting an initial temperature (:math:`T_0`) and a constant :math:`\alpha` such that :math:`T(t)`, the temperature at time `t`, is defined by the function:

.. math::

   T(t) = T_0 \alpha^t\\

And since time is assumed to be positive, this means that :math:`\alpha` has to be less than one if we want the temperature to drop (cool) with time. The temperature is used to decide whether a candidate solution that is worse than the current solution is accepted as a new solution. The higher the initial temperature, the more likely this is to happen and so the more the optimizer will explore, rather than accept a local optima. If :math:`\alpha` is closer to 0 or the initial temperature is low, then the optimizer will tend to choose one of the first local optima it finds. The actual choice of parameters has to be determined by the data. 

Gaussian Convolution
--------------------

Now we can look at `3.1. (get a new candidate by tweaking the current solution)`. 

In this case the new candidate is found by selecting values from a Normal distribution and adding them to the current solution. Since we are using a Normal distribution we know that about 68% of the values we pick will be within one standard deviation of the mean, 95% of the values will be within two standard deviations from the mean, and 99.7% of the data will be within three standard deviations from the mean. So by picking the mean (:math:`\mu`) and standard deviation (:math:`\sigma`) for our distribution, we can determine how far each new candidate is most likely to be from the previous solution, but not exactly how far (sometimes, although rarely, the chosen value will be more than three standard deviations from the mean).

Once again the :ref:`actual implementation <optimization-tweaks-gaussian>` has more information.

Sample Configuration File
-------------------------

This is a sample configuration file for running this test. The parameters of interest are for the annealing and the convolution. Note that I set a :math:`T_{final}` but in practice the time-out gets hit before this is actually reached.

.. csv-table:: Simulated Annealing Parameters
   :header: Variable,Configuration Option, Value

   :math:`T_0`, ``start_temperature``, :math:`10^{5}`
   :math:`T_{final}`, ``stop_temperature``, `0.01`
   :math:`\alpha`, ``alpha_temperature``, 0.99
   
.. csv-table:: Gaussian Convolution Parameters
   :header: Variable,Configuration Option, Value

   :math:`\mu`, ``location``, 0 
   :math:`\sigma`, ``scale``, 1

.. literalinclude:: data/simulated_annealing_exhaustive.ini
   :language: ini

